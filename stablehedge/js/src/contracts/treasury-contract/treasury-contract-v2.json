{
  "contractName": "TreasuryContractV2",
  "constructorInputs": [
    {
      "name": "authKeyId",
      "type": "bytes32"
    },
    {
      "name": "pk1",
      "type": "pubkey"
    },
    {
      "name": "pk2",
      "type": "pubkey"
    },
    {
      "name": "pk3",
      "type": "pubkey"
    },
    {
      "name": "pk4",
      "type": "pubkey"
    },
    {
      "name": "pk5",
      "type": "pubkey"
    },
    {
      "name": "anyhedgeContractFingerprint",
      "type": "bytes32"
    },
    {
      "name": "redemptionTokenCategory",
      "type": "bytes32"
    },
    {
      "name": "oraclePublicKey",
      "type": "bytes33"
    },
    {
      "name": "redemptionContractFingerprint",
      "type": "bytes32"
    }
  ],
  "abi": [
    {
      "name": "unlockWithNft",
      "inputs": [
        {
          "name": "keepGuarded",
          "type": "bool"
        }
      ]
    },
    {
      "name": "unlockWithMultiSig",
      "inputs": [
        {
          "name": "sig1",
          "type": "sig"
        },
        {
          "name": "sig2",
          "type": "sig"
        },
        {
          "name": "sig3",
          "type": "sig"
        }
      ]
    },
    {
      "name": "consolidate",
      "inputs": [
        {
          "name": "redemptionContractBaseBytecode",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "spendToAnyhedge",
      "inputs": [
        {
          "name": "anyhedgeBaseBytecode",
          "type": "bytes"
        },
        {
          "name": "shortPubkeyBytecode",
          "type": "bytes"
        },
        {
          "name": "argsSegment1",
          "type": "bytes"
        },
        {
          "name": "longLockScriptBytecode",
          "type": "bytes"
        },
        {
          "name": "nominalUnitsXSatsPerBchBytecode",
          "type": "bytes"
        },
        {
          "name": "satsForNominalUnitsAtHighLiquidationBytecode",
          "type": "bytes"
        },
        {
          "name": "shortInputSats",
          "type": "int"
        },
        {
          "name": "longInputSats",
          "type": "int"
        },
        {
          "name": "lowPriceBytecode",
          "type": "bytes"
        },
        {
          "name": "highPriceBytecode",
          "type": "bytes"
        },
        {
          "name": "startTsBytecode",
          "type": "bytes"
        },
        {
          "name": "maturityTsBytecode",
          "type": "bytes"
        },
        {
          "name": "longLiquidityFee",
          "type": "int"
        },
        {
          "name": "settlementServiceFee",
          "type": "int"
        }
      ]
    }
  ],
  "bytecode": "OP_10 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_1 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_UTXOTOKENAMOUNT OP_0 OP_NUMEQUALVERIFY OP_10 OP_ROLL OP_IF OP_0 OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY OP_ENDIF OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_1 OP_ELSE OP_10 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_0 OP_12 OP_ROLL OP_13 OP_ROLL OP_14 OP_ROLL OP_3 OP_6 OP_ROLL OP_7 OP_ROLL OP_8 OP_ROLL OP_9 OP_ROLL OP_10 OP_ROLL OP_5 OP_CHECKMULTISIGVERIFY OP_2DROP OP_2DROP OP_2DROP OP_1 OP_ELSE OP_10 OP_PICK OP_2 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUAL OP_NOT OP_VERIFY OP_INPUTINDEX OP_1SUB OP_1 OP_MAX OP_UTXOBYTECODE OP_INPUTINDEX OP_1ADD OP_TXINPUTCOUNT OP_1SUB OP_MIN OP_UTXOBYTECODE OP_2 OP_PICK OP_EQUALVERIFY OP_OVER OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_DUP OP_SIZE OP_NIP OP_TXINPUTCOUNT OP_1ADD OP_4 OP_MUL OP_SUB OP_SPLIT OP_NIP OP_DUP OP_INPUTINDEX OP_4 OP_MUL OP_SPLIT OP_NIP OP_8 OP_SPLIT OP_DROP OP_4 OP_SPLIT OP_BIN2NUM OP_SWAP OP_BIN2NUM OP_SUB OP_INPUTINDEX OP_UTXOVALUE OP_NUMEQUALVERIFY OP_DUP OP_SIZE OP_NIP OP_4 OP_SUB OP_SPLIT OP_NIP OP_BIN2NUM OP_2 OP_OUTPUTVALUE OP_TXOUTPUTCOUNT OP_4 OP_LESSTHANOREQUAL OP_VERIFY OP_2 OP_PICK OP_15 OP_PICK OP_SIZE OP_NIP OP_0 OP_GREATERTHAN OP_IF OP_13 OP_PICK OP_16 OP_PICK OP_HASH256 OP_EQUALVERIFY 23 OP_4 OP_PICK OP_CAT 21 OP_CAT OP_13 OP_PICK OP_CAT 20 OP_CAT OP_12 OP_PICK OP_CAT 20 OP_CAT OP_5 OP_PICK OP_CAT OP_16 OP_PICK OP_CAT OP_DUP OP_HASH256 aa20 OP_OVER OP_CAT 87 OP_CAT OP_3 OP_ROLL OP_DROP OP_SWAP OP_TOALTSTACK OP_SWAP OP_FROMALTSTACK OP_2DROP OP_ENDIF OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_4 OP_NUMEQUAL OP_IF OP_DUP OP_3 OP_OUTPUTVALUE OP_ADD OP_NIP OP_3 OP_OUTPUTBYTECODE OP_3 OP_PICK OP_EQUALVERIFY OP_ENDIF OP_SUB OP_0 OP_NUMEQUALVERIFY OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_DROP OP_1 OP_ELSE OP_10 OP_ROLL OP_3 OP_NUMEQUALVERIFY OP_6 OP_ROLL OP_10 OP_PICK OP_HASH256 OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_13 OP_PICK OP_1 OP_SPLIT OP_NIP 11 OP_PICK 13 OP_PICK OP_ADD OP_DUP 18 OP_PICK 18 OP_PICK OP_CAT 17 OP_PICK OP_CAT 16 OP_PICK OP_CAT OP_OVER OP_SIZE OP_NIP OP_CAT OP_SWAP OP_CAT 12 OP_PICK OP_CAT 11 OP_ROLL OP_CAT 21 OP_CAT OP_11 OP_ROLL OP_CAT OP_15 OP_ROLL OP_CAT 23 OP_CAT OP_3 OP_PICK OP_CAT OP_14 OP_PICK OP_CAT OP_13 OP_PICK OP_CAT OP_12 OP_ROLL OP_CAT OP_DUP OP_HASH256 aa20 OP_SWAP OP_CAT 87 OP_CAT OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_15 OP_ROLL OP_1 OP_SPLIT OP_NIP OP_BIN2NUM OP_0 OP_GREATERTHAN OP_VERIFY OP_14 OP_ROLL OP_1 OP_SPLIT OP_DROP 51 OP_EQUAL OP_IF OP_13 OP_PICK OP_1 OP_SPLIT OP_NIP OP_DUP OP_8 OP_PICK OP_EQUAL OP_OVER OP_10 OP_PICK OP_EQUAL OP_BOOLOR OP_OVER OP_11 OP_PICK OP_EQUAL OP_BOOLOR OP_OVER OP_12 OP_PICK OP_EQUAL OP_BOOLOR OP_OVER OP_13 OP_PICK OP_EQUAL OP_BOOLOR OP_VERIFY OP_DROP OP_ENDIF 13 OP_ROLL OP_1 OP_SPLIT OP_NIP OP_BIN2NUM 13 OP_ROLL OP_1 OP_SPLIT OP_NIP OP_BIN2NUM OP_SUB 6054 809706 OP_WITHIN OP_VERIFY 11 OP_ROLL OP_1 OP_SPLIT OP_NIP OP_BIN2NUM 11 OP_ROLL OP_1 OP_SPLIT OP_NIP OP_BIN2NUM OP_DIV OP_2 OP_GREATERTHANOREQUAL OP_VERIFY 2306 OP_ROT OP_SIZE OP_NIP OP_ADD OP_3 OP_PICK OP_SIZE OP_NIP OP_ADD OP_4 OP_PICK OP_SIZE OP_NIP OP_ADD OP_ROT OP_OVER OP_ADD OP_15 OP_ROLL d200 OP_INPUTINDEX OP_INPUTBYTECODE OP_SIZE OP_NIP OP_ADD OP_4 OP_ROLL OP_SIZE OP_NIP OP_ADD OP_15 OP_PICK OP_4 OP_ROLL OP_ADD OP_ADD OP_0 OP_16 OP_PICK OP_0 OP_GREATERTHAN OP_IF OP_4 OP_PICK OP_NIP OP_ELSE OP_16 OP_PICK OP_0 OP_LESSTHAN OP_IF OP_5 OP_PICK OP_NIP OP_ENDIF OP_ENDIF OP_DUP OP_SIZE OP_NIP OP_0 OP_GREATERTHAN OP_IF OP_15 OP_PICK 14 OP_DIV 11 OP_PICK OP_ABS 2202 OP_2 OP_PICK OP_WITHIN OP_VERIFY OP_2 OP_PICK 12 OP_PICK OP_ABS OP_ADD OP_2 OP_PICK OP_SIZE OP_NIP OP_ADD OP_9 OP_ADD OP_3 OP_ROLL OP_DROP OP_SWAP OP_TOALTSTACK OP_SWAP OP_FROMALTSTACK OP_1 OP_OUTPUTBYTECODE OP_2 OP_PICK OP_EQUALVERIFY OP_1 OP_OUTPUTVALUE 12 OP_PICK OP_ABS OP_NUMEQUALVERIFY OP_DROP OP_ENDIF 11 OP_PICK OP_0 OP_GREATERTHAN OP_IF OP_3 OP_PICK 4b OP_MUL 0f27 OP_ADD 1027 OP_DIV 12 OP_PICK 2202 OP_2 OP_PICK OP_WITHIN OP_VERIFY OP_2 OP_OUTPUTBYTECODE OP_3 OP_PICK 14 OP_PICK OP_ADD OP_OVER OP_SIZE OP_NIP OP_ADD OP_9 OP_ADD OP_4 OP_ROLL OP_DROP OP_SWAP OP_TOALTSTACK OP_SWAP OP_TOALTSTACK OP_SWAP OP_FROMALTSTACK OP_FROMALTSTACK OP_2 OP_OUTPUTVALUE 14 OP_PICK OP_NUMEQUALVERIFY OP_2DROP OP_ENDIF OP_0 OP_OUTPUTVALUE OP_4 OP_ROLL OP_NUMEQUALVERIFY OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_0 OP_UTXOVALUE OP_15 OP_ROLL OP_3 OP_ROLL OP_10 OP_ADD OP_WITHIN OP_VERIFY OP_1 OP_UTXOVALUE OP_ROT OP_GREATERTHANOREQUAL OP_VERIFY OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_1 OP_ENDIF OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Smart Contract fingerprint\n// https://bitcoincashresearch.org/t/smart-contract-fingerprinting-a-method-for-pattern-recognition-and-analysis-in-bitcoin-cash/1441\n\n\n/**\nValues for references, refer here when seeing asterisk in parenthesis (*)\n    10B base tx fee - 4B version | 4B locktime | 2B input & output (we assume it only takes 1 byte each where both inputs dont exceed 253)\n    9B BCH output base size - 8B satoshis amount | 1B lockscript prefix | 0B token prefix\n    43B cashscript input base size - 32B txid | 4B index | 4B sequence | 3B unlocking script count (this is because it's likely greater than 255)\n    41B p2pkh input base size - 32B txid | 4B index | 4B sequence | 1B unlocking script count (this is because it's likely less than 255)\n    148B p2pkh input size - for ECDSA signatures, used by anyhedge's library. although schnorr(141B) is now more common\n */\n\ncontract TreasuryContractV2(\n    bytes32 authKeyId, // 32 B token category of authkey nft\n    pubkey pk1, // 33 B\n    pubkey pk2, // 33 B\n    pubkey pk3, // 33 B\n    pubkey pk4, // 33 B\n    pubkey pk5, // 33 B\n    bytes32 anyhedgeContractFingerprint, // 32 B smart contract fingerprint of anyhedge smart contract\n    bytes32 redemptionTokenCategory, // 32 B\n    bytes33 oraclePublicKey, // 33 B\n    bytes32 redemptionContractFingerprint, // 32 B smart contract fingerprint of redemption contract\n) {\n    // Based on Authguard\n    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash\n    function unlockWithNft(bool keepGuarded) {\n        // Check that the first input holds the AuthKey NFT\n        require(tx.inputs[1].tokenCategory == authKeyId);\n        require(tx.inputs[1].tokenAmount == 0);\n\n        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant\n        if(keepGuarded){\n            // Self preservation of AuthGuard covenant as the first output\n            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);\n        }\n    }\n\n    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {\n        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3, pk4, pk5]));\n    }\n\n    /**\n        This allows contract to consolidate or create a UTXO with specific satoshis amount\n        This consolidate tx has the following requirements:\n            1. First input and output is used as fee funder for the consolidate tx.\n                This can be any wallet (e.g. p2sh, p2pkh)\n            2. All the inputs after input#0 must be from this smart contract\n            3. The output#1 has to be an OP_RETURN output\n            4. The OP_RETURN data must be of length 4 * inputs.length + 1\n            5. OP_RETURN data is a sequence of 4 byte numbers which represents cumulative amounts\n                of the inputs' satoshis amount.\n                This first 4 bytes is zero, the second 4 bytes is set as zero since\n                it represents input#0 and input#0 is not from this smart contract,\n                the third 4 bytes is the amount of input#1,\n                the fourth 4 bytes is the cumulative amount of the first two inputs, and so on.\n            6. This makes the last 4 bytes the cumulative amount of the smart contract's inputs.\n                Condition 1 above is a way to ensure that this condition is true.\n            7. output#2 and output#3 (if exists) must have a total satoshis equal to last 4 bytes\n                in the cumulitive amounts OP_RETURN data.\n            8. The recipient for output#2 and #3 should be this smart contract.\n\n        Based on the conditions above, the transaction fee is covered by the executor of the\n        consolidate transaction to prevent abuse of this function and result in loss of funds.\n    */\n    function consolidate(bytes redemptionContractBaseBytecode) {\n        bytes inputLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.inputs[0].lockingBytecode != inputLockScript);\n\n        // this ensures all inputs are from this smart contract's\n        // we check if adjacent inputs are from the same address\n        bytes prevInputLockScript = tx.inputs[max(this.activeInputIndex - 1, 1)].lockingBytecode;\n        bytes nextInputLockScript = tx.inputs[min(this.activeInputIndex + 1, tx.inputs.length - 1)].lockingBytecode;\n        require(inputLockScript == nextInputLockScript);\n        require(inputLockScript == prevInputLockScript);\n\n        bytes OP_DATA = tx.outputs[1].lockingBytecode;\n        bytes cumulativeAmounts = OP_DATA.split(OP_DATA.length - (tx.inputs.length+1) * 4)[1];\n\n        bytes segment = cumulativeAmounts.split(this.activeInputIndex * 4)[1].split(8)[0];\n        bytes prevCumulativeBytes, bytes cumulativeBytes = segment.split(4);\n        int inputAmount = int(cumulativeBytes) - int(prevCumulativeBytes);\n        require(tx.inputs[this.activeInputIndex].value == inputAmount);\n\n        int totalInputSats = int(cumulativeAmounts.split(cumulativeAmounts.length - 4)[1]);\n        int totalOutputSats = tx.outputs[2].value;\n\n        require(tx.outputs.length <= 4);\n        bytes recipientLockScript = inputLockScript;\n        if (redemptionContractBaseBytecode.length > 0) {\n            require(redemptionContractFingerprint == hash256(redemptionContractBaseBytecode));\n            bytes redemptionContractBytecode = bytes(35) + inputLockScript +\n                bytes(33) + oraclePublicKey +\n                bytes(32) + redemptionTokenCategory +\n                bytes(32) + authKeyId +\n                redemptionContractBaseBytecode;\n\n            bytes32 redemptionContractScriptHash = hash256(redemptionContractBytecode);\n            recipientLockScript = new LockingBytecodeP2SH32(redemptionContractScriptHash);\n        }\n        require(tx.outputs[2].lockingBytecode == recipientLockScript);\n\n        if (tx.outputs.length == 4) {\n            totalOutputSats = totalOutputSats + tx.outputs[3].value;\n            require(tx.outputs[3].lockingBytecode == inputLockScript);\n        }\n\n        // 13 => 10 base fee + 3 OP_DATA length prefix + 4 OP_DATA prefix of 0x00000000\n        // inputs.length * 800 => 796 input fee + 4 bytes from OP_DATA\n        // 45 bytes per output => BCH only with p2sh32 address\n        // int maxFee = 17 + (tx.inputs.length * 800) + ((tx.outputs.length - 1) * 45);\n        int diff = totalInputSats - totalOutputSats;\n\n        // using '<=' instead of '==' so creator of transaction can still optimize fee size\n        // too small fees will just be rejected by min tx fee requirement\n        require(diff == 0);\n    }\n\n    /**\n        Current vulnerabilities seen:\n            1. ...\n     */\n    function spendToAnyhedge(\n        bytes anyhedgeBaseBytecode,\n        bytes shortPubkeyBytecode,\n        bytes argsSegment1, // enableMutualRedemption + longPubkey\n        bytes longLockScriptBytecode, // type bytes\n        bytes nominalUnitsXSatsPerBchBytecode, // int type\n        bytes satsForNominalUnitsAtHighLiquidationBytecode,\n        int shortInputSats,\n        int longInputSats,\n        bytes lowPriceBytecode, // int type\n        bytes highPriceBytecode, // int type\n        bytes startTsBytecode, // int type\n        bytes maturityTsBytecode, // int type\n        int longLiquidityFee,\n        int settlementServiceFee,\n    ) {\n        require(anyhedgeContractFingerprint == hash256(anyhedgeBaseBytecode));\n        bytes thisLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;\n        bytes longLockScript = longLockScriptBytecode.split(1)[1];\n\n        int payoutSats = shortInputSats + longInputSats;\n        bytes payoutSatsBytes = bytes(payoutSats);\n\n        bytes contractParametersBytecode = maturityTsBytecode +\n            startTsBytecode +\n            highPriceBytecode +\n            lowPriceBytecode +\n            bytes(payoutSatsBytes.length) + payoutSatsBytes +\n            satsForNominalUnitsAtHighLiquidationBytecode +\n            nominalUnitsXSatsPerBchBytecode +\n            bytes(33) + oraclePublicKey +\n            longLockScriptBytecode + \n            bytes(35) + thisLockScript +\n            argsSegment1 +\n            shortPubkeyBytecode;\n\n        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;\n        bytes32 scriptHash = hash256(contractBytecode);\n        bytes35 anyhedgeLockingBytecode = new LockingBytecodeP2SH32(scriptHash);\n        require(tx.outputs[0].lockingBytecode == anyhedgeLockingBytecode);\n\n        // Require that the contract is not a simple hedge\n        int satsForNominalUnitsAtHighLiquidation = int(satsForNominalUnitsAtHighLiquidationBytecode.split(1)[1]);\n        require(satsForNominalUnitsAtHighLiquidation > 0);\n\n        // Check short mutual redeem pubkey must be one of contract's pubkeys\n        // if mutual redemption is enabled\n        if (argsSegment1.split(1)[0] == 0x51) {\n            bytes shortPubkey = shortPubkeyBytecode.split(1)[1];\n            require(shortPubkey == pk1 || shortPubkey == pk2 || shortPubkey == pk3 || shortPubkey == pk4 || shortPubkey == pk5);\n        }\n\n        // Necessary to ensure duration is not too long that it's unaccessible\n        // and not too short, else\n        // anyone can keep placing short positions just to profit from liquidity fee\n        int maturityTs = int(maturityTsBytecode.split(1)[1]);\n        int startTs = int(startTsBytecode.split(1)[1]);\n        int durationSeconds = maturityTs - startTs;\n        require(within(durationSeconds, 21600, 432000)); // 21600sec = 6hrs | 432000sec = 5days\n\n        // This implies price range is wide enough but does not show how close\n        // one boundary is to the start price\n        int highPrice = int(highPriceBytecode.split(1)[1]);\n        int lowPrice = int(lowPriceBytecode.split(1)[1]);\n        int priceMult = highPrice / lowPrice;\n        require(priceMult >= 2);\n\n\n        /**\n        inputScriptSizeData = 211B addtl input script fee\n            164B AH payout parameters size: 16B price message | 64B signature | 2B length prefixes. multiplied by 2 for settlement & previous price message\n            4B for selector; an integer which determines what function to run in the smart contract \n            43B cashscript input base size(*): input for AH settlement tx\n         */\n        /**\n        anyhedgeSettlementData = 1571B\n           211B inputScriptSizeData;\n           1332B DUST_LIMIT, when settlement prices for AH is at min/max https://bitcoincashresearch.org/t/friday-night-challenge-worst-case-dust/1181/2 \n           10B base tx fee(*); for AH settlement tx\n           9B BCH output base size(*); for short payout in AH settlement tx\n           9B BCH output base size(*); for long payout in AH settlement tx\n         */\n\n        int settlementFee = 1571 + contractBytecode.length + longLockScript.length + thisLockScript.length;\n        int totalFundingSats = payoutSats + settlementFee;\n        int longFundingSats = longInputSats; // long just needs the input sats while short covers all fee\n\n        /**\n        thisFundingTxData = 210; (NOTE: the addtl size from fees like LP fee and settlement fee is not yet here)\n            9B BCH output base size(*); for this tx's AH funding utxo\n            10B base tx fee(*); this funding tx\n            43B cashscript input base size(*); for short's funding input\n            148B p2pkh input size(*); for long's funding input, assuming it's p2pkh\n         */\n        int fundingTxFee = 210 + tx.inputs[this.activeInputIndex].unlockingBytecode.length + anyhedgeLockingBytecode.length;\n        int shortFundingSats = shortInputSats + settlementFee + fundingTxFee;\n\n        // liquidity provider fee\n        bytes lpFeeRecipient = 0x;\n        if (longLiquidityFee > 0) {\n            lpFeeRecipient = longLockScript;\n        } else if (longLiquidityFee < 0) {\n            lpFeeRecipient = thisLockScript;\n        }\n        if (lpFeeRecipient.length > 0) {\n            int maxLiquidityFee = shortInputSats / 20; // this is 5% of short input sats\n            require(within(abs(longLiquidityFee), 546, maxLiquidityFee));\n            shortFundingSats = shortFundingSats + abs(longLiquidityFee) + lpFeeRecipient.length + 9; // 9B BCH output base size(*)\n            require(tx.outputs[1].lockingBytecode == lpFeeRecipient);\n            require(tx.outputs[1].value == abs(longLiquidityFee));\n        }\n\n\n        // settlement service fee\n        if (settlementServiceFee > 0) {\n            // this is 0.75% of total funding sats\n            int maxSettlementServiceFee = (totalFundingSats * 75 + 9999) / 10000;\n            require(within(settlementServiceFee, 546, maxSettlementServiceFee));\n\n            bytes settlementServiceFeeRecipient = tx.outputs[2].lockingBytecode;\n            shortFundingSats = shortFundingSats + settlementServiceFee + settlementServiceFeeRecipient.length + 9; // 9B BCH output base size(*)\n            require(tx.outputs[2].value == settlementServiceFee);\n            // TODO: might need to check recipient as well\n        }\n\n        // This output is used as input for settlement tx of AH contract\n        require(tx.outputs[0].value == totalFundingSats);\n\n        // will ensure treasury contract only has input 0\n        require(this.activeInputIndex == 0);\n        require(within(tx.inputs[0].value, shortInputSats, shortFundingSats + 10)); // added + 10 for error margin\n        require(tx.inputs[1].value >= longFundingSats);\n    }\n}\n",
  "compiler": {
    "name": "cashc",
    "version": "0.8.0"
  },
  "updatedAt": "2025-09-26T06:30:29.464Z"
}