pragma cashscript ^0.8.0;

contract TreasuryContractV2(
    bytes32 authKeyId, // 32 B token category of authkey nft
    pubkey pk1, // 33 B
    pubkey pk2, // 33 B
    pubkey pk3, // 33 B
    pubkey pk4, // 33 B
    pubkey pk5, // 33 B
    bytes anyhedgeBaseBytecode, // an artifact bytecode of anyhedge smart contract
) {
    // Based on Authguard
    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash
    function unlockWithNft(bool keepGuarded) {
        // Check that the first input holds the AuthKey NFT
        require(tx.inputs[1].tokenCategory == authKeyId);
        require(tx.inputs[1].tokenAmount == 0);

        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant
        if(keepGuarded){
            // Self preservation of AuthGuard covenant as the first output
            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        }
    }

    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {
        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3, pk4, pk5]));
    }

    // Exploitable, someone could keep consolidating utxos until balance
    //   reaches zero due to transaction fees
    function consolidate() {
        require(tx.outputs.length <= 2);
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));
        require(tx.outputs[0].lockingBytecode == thisLockScript);
        if (tx.outputs.length == 2) {
            require(tx.outputs[1].lockingBytecode == thisLockScript);
        }
    }

    function spendToAnyhedge(
        bytes argsSegment1, // enableMutualRedemption + shortPubkey + longPubkey
        bytes argsSegment2, // satsForNominalUnitsAtHighLiquidationBytecode + nominalUnitsXSatsPerBchBytecode + oraclePubkey + longLockScript
        int shortInputSats,
        int longInputSats,
        bytes lowPriceBytecode, // int type
        bytes highPriceBytecode, // int type
        bytes startTsBytecode, // int type
        bytes maturityTsBytecode, // int type
    ) {
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));

        int payoutSats = shortInputSats + longInputSats;
        bytes payoutSatsBytes = bytes(payoutSats);

        bytes contractParametersBytecode = maturityTsBytecode +
            startTsBytecode +
            highPriceBytecode +
            lowPriceBytecode +
            bytes(payoutSatsBytes.length) + payoutSatsBytes +
            argsSegment2 +
            bytes(35) + thisLockScript +
            argsSegment1;

        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;
        bytes32 scriptHash = hash256(contractBytecode);
        bytes35 lockingBytecode = new LockingBytecodeP2SH32(scriptHash);
        require(tx.outputs[0].lockingBytecode == lockingBytecode);
        if (tx.outputs.length >= 2) {
            require(tx.outputs[1].lockingBytecode == thisLockScript);
        }

        // Necessary to ensure duration is not too long that it's unaccessible
        int maturityTs = int(maturityTsBytecode.split(1)[1]);
        int startTs = int(startTsBytecode.split(1)[1]);
        int duration = maturityTs - startTs;
        require(within(duration, 0, 432000)); // 432000 is 5 days in seconds

        // This implies price range is wide enough but does not show how close
        // one boundary is to the start price
        int highPrice = int(highPriceBytecode.split(1)[1]);
        int lowPrice = int(lowPriceBytecode.split(1)[1]);
        int priceMult = highPrice / lowPrice;
        require(priceMult >= 2);

        // additional 1991 for settlement tx fee
        require(payoutSats + 1991 == tx.outputs[0].value);
        require(tx.inputs[0].value >= shortInputSats + 1991);
        require(tx.inputs[1].value >= longInputSats);
    }
}
