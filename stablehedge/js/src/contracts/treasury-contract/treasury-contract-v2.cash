pragma cashscript ^0.8.0;

contract TreasuryContractV2(
    bytes32 authKeyId, // 32 B token category of authkey nft
    pubkey pk1, // 33 B
    pubkey pk2, // 33 B
    pubkey pk3, // 33 B
    pubkey pk4, // 33 B
    pubkey pk5, // 33 B
    bytes anyhedgeBaseBytecode, // an artifact bytecode of anyhedge smart contract
) {
    // Based on Authguard
    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash
    function unlockWithNft(bool keepGuarded) {
        // Check that the first input holds the AuthKey NFT
        require(tx.inputs[1].tokenCategory == authKeyId);
        require(tx.inputs[1].tokenAmount == 0);

        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant
        if(keepGuarded){
            // Self preservation of AuthGuard covenant as the first output
            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        }
    }

    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {
        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3, pk4, pk5]));
    }

    // Exploitable, someone could keep consolidating utxos until balance
    //   reaches zero due to transaction fees
    function consolidate() {
        require(tx.outputs.length <= 2);
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));
        require(tx.outputs[0].lockingBytecode == thisLockScript);
        if (tx.outputs.length == 2) {
            require(tx.outputs[1].lockingBytecode == thisLockScript);
        }
    }

    function spendToAnyhedge(
        bytes argsSegment1, // enableMutualRedemption + shortPubkey + longPubkey
        bytes argsSegment2, // satsForNominalUnitsAtHighLiquidationBytecode + nominalUnitsXSatsPerBchBytecode + oraclePubkey
        bytes longLockScriptBytecode, // type bytes
        int shortInputSats,
        int longInputSats,
        bytes lowPriceBytecode, // int type
        bytes highPriceBytecode, // int type
        bytes startTsBytecode, // int type
        bytes maturityTsBytecode, // int type
        int longLiquidityFee,
    ) {
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));

        int payoutSats = shortInputSats + longInputSats;
        bytes payoutSatsBytes = bytes(payoutSats);

        bytes contractParametersBytecode = maturityTsBytecode +
            startTsBytecode +
            highPriceBytecode +
            lowPriceBytecode +
            bytes(payoutSatsBytes.length) + payoutSatsBytes +
            argsSegment2 +
            longLockScriptBytecode + 
            bytes(35) + thisLockScript +
            argsSegment1;

        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;
        bytes32 scriptHash = hash256(contractBytecode);
        bytes35 lockingBytecode = new LockingBytecodeP2SH32(scriptHash);
        require(tx.outputs[0].lockingBytecode == lockingBytecode);

        // Necessary to ensure duration is not too long that it's unaccessible
        int maturityTs = int(maturityTsBytecode.split(1)[1]);
        int startTs = int(startTsBytecode.split(1)[1]);
        int duration = maturityTs - startTs;
        require(within(duration, 0, 432000)); // 432000 is 5 days in seconds

        // This implies price range is wide enough but does not show how close
        // one boundary is to the start price
        int highPrice = int(highPriceBytecode.split(1)[1]);
        int lowPrice = int(lowPriceBytecode.split(1)[1]);
        int priceMult = highPrice / lowPrice;
        require(priceMult >= 2);

        // 1332 is DUST_LIMIT, when settlement prices for AH is at min/max
        // https://bitcoincashresearch.org/t/friday-night-challenge-worst-case-dust/1181/2
        //
        // 698 is for settlement tx fee, added ~15-20 sats for margin
        // value is based on minerCostInSatoshis in AH contract data
        int settlementFee = 2030; // 1332 + 698 = 2030
        int totalFundingSats = payoutSats + settlementFee;
        int longFundingSats = longInputSats; // long just needs the input sats while short covers all fee

        // based on this contract's input size + base tx fee of 10 sats
        // added ~5-10 sats for margin
        // might have to change if source code changes (e.g. increases in size)
        // did not include long funding fee, it should be covered by long
        int shortFundingInputFee = 1025;
        int shortFundingSats = shortInputSats + settlementFee + shortFundingInputFee;
        if (longLiquidityFee > 0) {
            int maxLiquidityFee = shortInputSats / 20; // this is 5% of short input sats
            require(within(longLiquidityFee, 546, maxLiquidityFee));
            shortFundingSats = shortFundingSats + longLiquidityFee + 45; // 45 is output fee
            bytes longLockScript = longLockScriptBytecode.split(1)[1];
            require(tx.outputs[1].value == longLiquidityFee);
            require(tx.outputs[1].lockingBytecode == longLockScript);
        }

        // This output is used as input for settlement tx of AH contract
        require(tx.outputs[0].value == totalFundingSats);
        require(tx.inputs[0].value == shortFundingSats);
        require(tx.inputs[1].value >= longFundingSats);
    }
}
