pragma cashscript ^0.8.0;

contract TreasuryContractV2(
    bytes32 authKeyId, // 32 B token category of authkey nft
    pubkey pk1, // 33 B
    pubkey pk2, // 33 B
    pubkey pk3, // 33 B
    pubkey pk4, // 33 B
    pubkey pk5, // 33 B
    bytes anyhedgeBaseBytecode, // an artifact bytecode of anyhedge smart contract
) {
    // Based on Authguard
    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash
    function unlockWithNft(bool keepGuarded) {
        // Check that the first input holds the AuthKey NFT
        require(tx.inputs[1].tokenCategory == authKeyId);
        require(tx.inputs[1].tokenAmount == 0);

        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant
        if(keepGuarded){
            // Self preservation of AuthGuard covenant as the first output
            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        }
    }

    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {
        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3, pk4, pk5]));
    }

    /**
        This allows contract to consolidate or create a UTXO with specific satoshis amount
        This consolidate tx has the following requirements:
            1. All the inputs must be from this smart contract
            2. The first output has to be an OP_RETURN output
            3. The OP_RETURN data must be of length 4 * inputs.length
            4. OP_RETURN data is a sequence of 4 byte numbers which represents cumulative amounts.
               This first 4 bytes is zero, the second 4 bytes the satoshi amount of first input,
               the third 4 bytes is the cumulative amount of the first two inputs, and so on.
            5. This makes the last 4 bytes the cumulative amount of all inputs. Condition 1 above
                is a way to ensure that this condition is true.

        Current vulnerabilities seen:
            1. Anyone can keep spamming consolidate, potentially consume a lot of BCH as tx fee
    */
    function consolidate() {
        // this ensures all inputs are from this smart contract's
        // we check if adjacent inputs are from the same address
        bytes inputLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes prevInputLockScript = tx.inputs[max(this.activeInputIndex - 1, 0)].lockingBytecode;
        bytes nextInputLockScript = tx.inputs[min(this.activeInputIndex + 1, tx.inputs.length - 1)].lockingBytecode;
        require(inputLockScript == nextInputLockScript);
        require(inputLockScript == prevInputLockScript);

        bytes OP_DATA = tx.outputs[0].lockingBytecode;
        bytes cumulativeAmounts = OP_DATA.split(OP_DATA.length - (tx.inputs.length+1) * 4)[1];

        bytes segment = cumulativeAmounts.split(this.activeInputIndex * 4)[1].split(8)[0];
        bytes prevCumulativeBytes, bytes cumulativeBytes = segment.split(4);
        int inputAmount = int(cumulativeBytes) - int(prevCumulativeBytes);
        require(tx.inputs[this.activeInputIndex].value == inputAmount);

        int totalInputSats = int(cumulativeAmounts.split(cumulativeAmounts.length - 4)[1]);
        int totalOutputSats = tx.outputs[1].value;

        require(tx.outputs.length <= 3);
        require(tx.outputs[1].lockingBytecode == inputLockScript);
        if (tx.outputs.length == 3) {
            totalOutputSats = totalOutputSats + tx.outputs[2].value;
            require(tx.outputs[1].lockingBytecode == tx.outputs[2].lockingBytecode);
        }

        // 13 => 10 base fee + 3 OP_DATA length prefix + 4 OP_DATA prefix of 0x00000000
        // inputs.length * 800 => 796 input fee + 4 bytes from OP_DATA
        // 45 bytes per output => BCH only with p2sh32 address
        int maxFee = 17 + (tx.inputs.length * 800) + ((tx.outputs.length - 1) * 45);
        int diff = totalInputSats - totalOutputSats;

        // using '<=' instead of '==' so creator of transaction can still optimize fee size
        // too small fees will just be rejected by min tx fee requirement
        require(diff <= maxFee);
    }

    /**
        Current vulnerabilities seen:
            1. ...
     */
    function spendToAnyhedge(
        bytes shortPubkeyBytecode,
        bytes argsSegment1, // enableMutualRedemption + longPubkey
        bytes longLockScriptBytecode, // type bytes
        bytes argsSegment2, // nominalUnitsXSatsPerBchBytecode + oraclePubkey
        bytes satsForNominalUnitsAtHighLiquidationBytecode,
        int shortInputSats,
        int longInputSats,
        bytes lowPriceBytecode, // int type
        bytes highPriceBytecode, // int type
        bytes startTsBytecode, // int type
        bytes maturityTsBytecode, // int type
        int longLiquidityFee,
    ) {
        bytes thisLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;

        int payoutSats = shortInputSats + longInputSats;
        bytes payoutSatsBytes = bytes(payoutSats);

        bytes contractParametersBytecode = maturityTsBytecode +
            startTsBytecode +
            highPriceBytecode +
            lowPriceBytecode +
            bytes(payoutSatsBytes.length) + payoutSatsBytes +
            satsForNominalUnitsAtHighLiquidationBytecode +
            argsSegment2 +
            longLockScriptBytecode + 
            bytes(35) + thisLockScript +
            argsSegment1 +
            shortPubkeyBytecode;

        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;
        bytes32 scriptHash = hash256(contractBytecode);
        bytes35 lockingBytecode = new LockingBytecodeP2SH32(scriptHash);
        require(tx.outputs[0].lockingBytecode == lockingBytecode);

        // Require that the contract is not a simple hedge
        int satsForNominalUnitsAtHighLiquidation = int(satsForNominalUnitsAtHighLiquidationBytecode.split(1)[1]);
        require(satsForNominalUnitsAtHighLiquidation > 0);

        // Check short mutual redeem pubkey must be one of contract's pubkeys
        // if mutual redemption is enabled
        if (argsSegment1.split(1)[0] == 0x51) {
            bytes shortPubkey = shortPubkeyBytecode.split(1)[1];
            require(shortPubkey == pk1 || shortPubkey == pk2 || shortPubkey == pk3 || shortPubkey == pk4 || shortPubkey == pk5);
        }

        // Necessary to ensure duration is not too long that it's unaccessible
        // and not too short, else
        // anyone can keep placing short positions just to profit from liquidity fee
        int maturityTs = int(maturityTsBytecode.split(1)[1]);
        int startTs = int(startTsBytecode.split(1)[1]);
        int durationSeconds = maturityTs - startTs;
        require(within(durationSeconds, 7200, 432000)); // 7200sec = 2hrs | 432000sec = 5days

        // This implies price range is wide enough but does not show how close
        // one boundary is to the start price
        int highPrice = int(highPriceBytecode.split(1)[1]);
        int lowPrice = int(lowPriceBytecode.split(1)[1]);
        int priceMult = highPrice / lowPrice;
        require(priceMult >= 2);

        // 1332 is DUST_LIMIT, when settlement prices for AH is at min/max
        // https://bitcoincashresearch.org/t/friday-night-challenge-worst-case-dust/1181/2
        //
        // 698 is for settlement tx fee, added ~15-20 sats for margin
        // value is based on minerCostInSatoshis in AH contract data
        int settlementFee = 2030; // 1332 + 698 = 2030
        int totalFundingSats = payoutSats + settlementFee;
        int longFundingSats = longInputSats; // long just needs the input sats while short covers all fee

        // based on this contract's input size + base tx fee of 10 sats
        // added ~5-10 sats for margin
        // might have to change if source code changes (e.g. increases in size)
        // did not include long funding fee, it should be covered by long
        int shortFundingInputFee = 1025;
        int shortFundingSats = shortInputSats + settlementFee + shortFundingInputFee;
        if (longLiquidityFee > 0) {
            int maxLiquidityFee = shortInputSats / 20; // this is 5% of short input sats
            require(within(longLiquidityFee, 546, maxLiquidityFee));
            shortFundingSats = shortFundingSats + longLiquidityFee + 45; // 45 is output fee
            bytes longLockScript = longLockScriptBytecode.split(1)[1];
            require(tx.outputs[1].value == longLiquidityFee);
            require(tx.outputs[1].lockingBytecode == longLockScript);
        }

        // This output is used as input for settlement tx of AH contract
        require(tx.outputs[0].value == totalFundingSats);

        // will ensure treasury contract only has input 0
        require(this.activeInputIndex == 0);
        require(within(tx.inputs[0].value, shortInputSats, shortFundingSats+1));
        require(tx.inputs[1].value >= longFundingSats);
    }
}
