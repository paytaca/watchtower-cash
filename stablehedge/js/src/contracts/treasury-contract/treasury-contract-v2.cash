pragma cashscript ^0.8.0;

contract TreasuryContractV2(
    bytes32 authKeyId, // 32 B token category of authkey nft
    pubkey pk1, // 33 B
    pubkey pk2, // 33 B
    pubkey pk3, // 33 B
    // pubkey pk4, // 33 B
    // pubkey pk5, // 33 B
    bytes anyhedgeBaseBytecode, // an artifact bytecode of anyhedge smart contract
) {
    // Based on Authguard
    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash
    function unlockWithNft(bool keepGuarded) {
        // Check that the first input holds the AuthKey NFT
        require(tx.inputs[1].tokenCategory == authKeyId);
        require(tx.inputs[1].tokenAmount == 0);

        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant
        if(keepGuarded){
            // Self preservation of AuthGuard covenant as the first output
            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        }
    }

    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {
        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3]));
    }

    function consolidate() {
        require(tx.outputs.length <= 2);
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));
        require(tx.outputs[0].lockingBytecode == thisLockScript);
        if (tx.outputs.length == 2) {
            require(tx.outputs[1].lockingBytecode == thisLockScript);
        }
    }

    function spendToAnyhedge(
        bytes argsSegment1, // enableMutualRedemption + shortPubkey + longPubkey
        bytes argsSegment2, // payoutSatsBytecode + satsForNominalUnitsAtHighLiquidationBytecode + nominalUnitsXSatsPerBchBytecode + oraclePubkey + longLockScript
        bytes payoutSatsBytecode, // int type
        bytes lowPriceBytecode, // int type
        bytes highPriceBytecode, // int type
        bytes startTsBytecode, // int type
        bytes maturityTsBytecode, // int type
    ) {
        bytes35 thisLockScript = new LockingBytecodeP2SH32(hash256(this.activeBytecode));

        bytes contractParametersBytecode = maturityTsBytecode +
            startTsBytecode +
            highPriceBytecode +
            lowPriceBytecode +
            payoutSatsBytecode + 
            argsSegment2 +
            bytes(35) + thisLockScript +
            argsSegment1;

        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;
        bytes32 scriptHash = hash256(contractBytecode);
        bytes35 lockingBytecode = new LockingBytecodeP2SH32(scriptHash);
        require(tx.outputs[0].lockingBytecode == lockingBytecode);
        if (tx.outputs.length == 2) {
            bytes35 thisBytecode = new LockingBytecodeP2SH32(hash256(this.activeBytecode));
            require(tx.outputs[1].lockingBytecode == thisBytecode);
        }

        // additional 1991 for settlement tx fee
        int payoutSats = int(payoutSatsBytecode.split(1)[1]) + 1991;
        require(payoutSats == tx.outputs[0].value);

        int maturityTs = int(maturityTsBytecode.split(1)[1]);
        int startTs = int(startTsBytecode.split(1)[1]);
        int duration = maturityTs - startTs;
        require(duration > 0 && duration <= 432000); // 432000 is 5 days in seconds

        int highPrice = int(highPriceBytecode.split(1)[1]);
        int lowPrice = int(lowPriceBytecode.split(1)[1]);
        int priceMult = highPrice / lowPrice;
        require(priceMult >= 2);
    }
}
