pragma cashscript ^0.8.0;

// Smart Contract fingerprint
// https://bitcoincashresearch.org/t/smart-contract-fingerprinting-a-method-for-pattern-recognition-and-analysis-in-bitcoin-cash/1441


/**
Values for references, refer here when seeing asterisk in parenthesis (*)
    10B base tx fee - 4B version | 4B locktime | 2B input & output (we assume it only takes 1 byte each where both inputs dont exceed 253)
    9B BCH output base size - 8B satoshis amount | 1B lockscript prefix | 0B token prefix
    43B cashscript input base size - 32B txid | 4B index | 4B sequence | 3B unlocking script count (this is because it's likely greater than 255)
    41B p2pkh input base size - 32B txid | 4B index | 4B sequence | 1B unlocking script count (this is because it's likely less than 255)
    148B p2pkh input size - for ECDSA signatures, used by anyhedge's library. although schnorr(141B) is now more common
 */

contract TreasuryContractV2(
    bytes32 authKeyId, // 32 B token category of authkey nft
    pubkey pk1, // 33 B
    pubkey pk2, // 33 B
    pubkey pk3, // 33 B
    pubkey pk4, // 33 B
    pubkey pk5, // 33 B
    bytes32 anyhedgeContractFingerprint, // 32 B smart contract fingerprint of anyhedge smart contract
    bytes32 redemptionTokenCategory, // 32 B
    bytes33 oraclePublicKey, // 33 B
    bytes32 redemptionContractFingerprint, // 32 B smart contract fingerprint of redemption contract
) {
    // Based on Authguard
    // https://github.com/mr-zwets/AuthGuard/blob/c5115b0df05c868018cc433e1047f5c5f6c8f7f7/AuthGuard.cash
    function unlockWithNft(bool keepGuarded) {
        // Check that the first input holds the AuthKey NFT
        require(tx.inputs[1].tokenCategory == authKeyId);
        require(tx.inputs[1].tokenAmount == 0);

        // if keepGuarded is false, the AuthHead can be released from the AuthGuard covenant
        if(keepGuarded){
            // Self preservation of AuthGuard covenant as the first output
            require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        }
    }

    function unlockWithMultiSig(sig sig1, sig sig2, sig sig3) {
        require(checkMultiSig([sig1, sig2, sig3], [pk1, pk2, pk3, pk4, pk5]));
    }

    /**
        This allows contract to consolidate or create a UTXO with specific satoshis amount
        This consolidate tx has the following requirements:
            1. First input and output is used as fee funder for the consolidate tx.
                This can be any wallet (e.g. p2sh, p2pkh)
            2. All the inputs after input#0 must be from this smart contract
            3. The output#1 has to be an OP_RETURN output
            4. The OP_RETURN data must be of length 4 * inputs.length + 1
            5. OP_RETURN data is a sequence of 4 byte numbers which represents cumulative amounts
                of the inputs' satoshis amount.
                This first 4 bytes is zero, the second 4 bytes is set as zero since
                it represents input#0 and input#0 is not from this smart contract,
                the third 4 bytes is the amount of input#1,
                the fourth 4 bytes is the cumulative amount of the first two inputs, and so on.
            6. This makes the last 4 bytes the cumulative amount of the smart contract's inputs.
                Condition 1 above is a way to ensure that this condition is true.
            7. output#2 and output#3 (if exists) must have a total satoshis equal to last 4 bytes
                in the cumulitive amounts OP_RETURN data.
            8. The recipient for output#2 and #3 should be this smart contract.

        Based on the conditions above, the transaction fee is covered by the executor of the
        consolidate transaction to prevent abuse of this function and result in loss of funds.
    */
    function consolidate(bytes redemptionContractBaseBytecode) {
        bytes inputLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;
        require(tx.inputs[0].lockingBytecode != inputLockScript);

        // this ensures all inputs are from this smart contract's
        // we check if adjacent inputs are from the same address
        bytes prevInputLockScript = tx.inputs[max(this.activeInputIndex - 1, 1)].lockingBytecode;
        bytes nextInputLockScript = tx.inputs[min(this.activeInputIndex + 1, tx.inputs.length - 1)].lockingBytecode;
        require(inputLockScript == nextInputLockScript);
        require(inputLockScript == prevInputLockScript);

        bytes OP_DATA = tx.outputs[1].lockingBytecode;
        bytes cumulativeAmounts = OP_DATA.split(OP_DATA.length - (tx.inputs.length+1) * 4)[1];

        bytes segment = cumulativeAmounts.split(this.activeInputIndex * 4)[1].split(8)[0];
        bytes prevCumulativeBytes, bytes cumulativeBytes = segment.split(4);
        int inputAmount = int(cumulativeBytes) - int(prevCumulativeBytes);
        require(tx.inputs[this.activeInputIndex].value == inputAmount);

        int totalInputSats = int(cumulativeAmounts.split(cumulativeAmounts.length - 4)[1]);
        int totalOutputSats = tx.outputs[2].value;

        require(tx.outputs.length <= 4);
        bytes recipientLockScript = inputLockScript;
        if (redemptionContractBaseBytecode.length > 0) {
            require(redemptionContractFingerprint == hash256(redemptionContractBaseBytecode));
            bytes redemptionContractBytecode = bytes(35) + inputLockScript +
                bytes(33) + oraclePublicKey +
                bytes(32) + redemptionTokenCategory +
                bytes(32) + authKeyId +
                redemptionContractBaseBytecode;

            bytes32 redemptionContractScriptHash = hash256(redemptionContractBytecode);
            recipientLockScript = new LockingBytecodeP2SH32(redemptionContractScriptHash);
        }
        require(tx.outputs[2].lockingBytecode == recipientLockScript);

        if (tx.outputs.length == 4) {
            totalOutputSats = totalOutputSats + tx.outputs[3].value;
            require(tx.outputs[3].lockingBytecode == inputLockScript);
        }

        // 13 => 10 base fee + 3 OP_DATA length prefix + 4 OP_DATA prefix of 0x00000000
        // inputs.length * 800 => 796 input fee + 4 bytes from OP_DATA
        // 45 bytes per output => BCH only with p2sh32 address
        // int maxFee = 17 + (tx.inputs.length * 800) + ((tx.outputs.length - 1) * 45);
        int diff = totalInputSats - totalOutputSats;

        // using '<=' instead of '==' so creator of transaction can still optimize fee size
        // too small fees will just be rejected by min tx fee requirement
        require(diff == 0);
    }

    /**
        Current vulnerabilities seen:
            1. ...
     */
    function spendToAnyhedge(
        bytes anyhedgeBaseBytecode,
        bytes shortPubkeyBytecode,
        bytes argsSegment1, // enableMutualRedemption + longPubkey
        bytes longLockScriptBytecode, // type bytes
        bytes nominalUnitsXSatsPerBchBytecode, // int type
        bytes satsForNominalUnitsAtHighLiquidationBytecode,
        int shortInputSats,
        int longInputSats,
        bytes lowPriceBytecode, // int type
        bytes highPriceBytecode, // int type
        bytes startTsBytecode, // int type
        bytes maturityTsBytecode, // int type
        int longLiquidityFee,
        int settlementServiceFee,
    ) {
        require(anyhedgeContractFingerprint == hash256(anyhedgeBaseBytecode));
        bytes thisLockScript = tx.inputs[this.activeInputIndex].lockingBytecode;
        bytes longLockScript = longLockScriptBytecode.split(1)[1];

        int payoutSats = shortInputSats + longInputSats;
        bytes payoutSatsBytes = bytes(payoutSats);

        bytes contractParametersBytecode = maturityTsBytecode +
            startTsBytecode +
            highPriceBytecode +
            lowPriceBytecode +
            bytes(payoutSatsBytes.length) + payoutSatsBytes +
            satsForNominalUnitsAtHighLiquidationBytecode +
            nominalUnitsXSatsPerBchBytecode +
            bytes(33) + oraclePublicKey +
            longLockScriptBytecode + 
            bytes(35) + thisLockScript +
            argsSegment1 +
            shortPubkeyBytecode;

        bytes contractBytecode = contractParametersBytecode + anyhedgeBaseBytecode;
        bytes32 scriptHash = hash256(contractBytecode);
        bytes35 anyhedgeLockingBytecode = new LockingBytecodeP2SH32(scriptHash);
        require(tx.outputs[0].lockingBytecode == anyhedgeLockingBytecode);

        // Require that the contract is not a simple hedge
        int satsForNominalUnitsAtHighLiquidation = int(satsForNominalUnitsAtHighLiquidationBytecode.split(1)[1]);
        require(satsForNominalUnitsAtHighLiquidation > 0);

        // Check short mutual redeem pubkey must be one of contract's pubkeys
        // if mutual redemption is enabled
        if (argsSegment1.split(1)[0] == 0x51) {
            bytes shortPubkey = shortPubkeyBytecode.split(1)[1];
            require(shortPubkey == pk1 || shortPubkey == pk2 || shortPubkey == pk3 || shortPubkey == pk4 || shortPubkey == pk5);
        }

        // Necessary to ensure duration is not too long that it's unaccessible
        // and not too short, else
        // anyone can keep placing short positions just to profit from liquidity fee
        int maturityTs = int(maturityTsBytecode.split(1)[1]);
        int startTs = int(startTsBytecode.split(1)[1]);
        int durationSeconds = maturityTs - startTs;
        require(within(durationSeconds, 21600, 432000)); // 21600sec = 6hrs | 432000sec = 5days

        // This implies price range is wide enough but does not show how close
        // one boundary is to the start price
        int highPrice = int(highPriceBytecode.split(1)[1]);
        int lowPrice = int(lowPriceBytecode.split(1)[1]);
        int priceMult = highPrice / lowPrice;
        require(priceMult >= 2);


        /**
        inputScriptSizeData = 211B addtl input script fee
            164B AH payout parameters size: 16B price message | 64B signature | 2B length prefixes. multiplied by 2 for settlement & previous price message
            4B for selector; an integer which determines what function to run in the smart contract 
            43B cashscript input base size(*): input for AH settlement tx
         */
        /**
        anyhedgeSettlementData = 1571B
           211B inputScriptSizeData;
           1332B DUST_LIMIT, when settlement prices for AH is at min/max https://bitcoincashresearch.org/t/friday-night-challenge-worst-case-dust/1181/2 
           10B base tx fee(*); for AH settlement tx
           9B BCH output base size(*); for short payout in AH settlement tx
           9B BCH output base size(*); for long payout in AH settlement tx
         */

        int settlementFee = 1571 + contractBytecode.length + longLockScript.length + thisLockScript.length;
        int totalFundingSats = payoutSats + settlementFee;
        int longFundingSats = longInputSats; // long just needs the input sats while short covers all fee

        /**
        thisFundingTxData = 210; (NOTE: the addtl size from fees like LP fee and settlement fee is not yet here)
            9B BCH output base size(*); for this tx's AH funding utxo
            10B base tx fee(*); this funding tx
            43B cashscript input base size(*); for short's funding input
            148B p2pkh input size(*); for long's funding input, assuming it's p2pkh
         */
        int fundingTxFee = 210 + tx.inputs[this.activeInputIndex].unlockingBytecode.length + anyhedgeLockingBytecode.length;
        int shortFundingSats = shortInputSats + settlementFee + fundingTxFee;

        // liquidity provider fee
        bytes lpFeeRecipient = 0x;
        if (longLiquidityFee > 0) {
            lpFeeRecipient = longLockScript;
        } else if (longLiquidityFee < 0) {
            lpFeeRecipient = thisLockScript;
        }
        if (lpFeeRecipient.length > 0) {
            int maxLiquidityFee = shortInputSats / 20; // this is 5% of short input sats
            require(within(abs(longLiquidityFee), 546, maxLiquidityFee));
            shortFundingSats = shortFundingSats + abs(longLiquidityFee) + lpFeeRecipient.length + 9; // 9B BCH output base size(*)
            require(tx.outputs[1].lockingBytecode == lpFeeRecipient);
            require(tx.outputs[1].value == abs(longLiquidityFee));
        }


        // settlement service fee
        if (settlementServiceFee > 0) {
            // this is 0.75% of total funding sats
            int maxSettlementServiceFee = (totalFundingSats * 75 + 9999) / 10000;
            require(within(settlementServiceFee, 546, maxSettlementServiceFee));

            bytes settlementServiceFeeRecipient = tx.outputs[2].lockingBytecode;
            shortFundingSats = shortFundingSats + settlementServiceFee + settlementServiceFeeRecipient.length + 9; // 9B BCH output base size(*)
            require(tx.outputs[2].value == settlementServiceFee);
            // TODO: might need to check recipient as well
        }

        // This output is used as input for settlement tx of AH contract
        require(tx.outputs[0].value == totalFundingSats);

        // will ensure treasury contract only has input 0
        require(this.activeInputIndex == 0);
        require(within(tx.inputs[0].value, shortInputSats, shortFundingSats + 10)); // added + 10 for error margin
        require(tx.inputs[1].value >= longFundingSats);
    }
}
